# 数据结构与算法之美 (2021.7.3 - 2021. )

## 入门篇：

### 1. 为什么学习数据结构与算法？

计算机，要学习基础，才能立于不败，因为技术更新很快，而基础的东西恰恰是那些不怎么变化的东西，也很难啃，算法即为其中之一。

掌握数据结构和算法，对阅读框架源码和理解其背后的设计思想非常有用。

### 2. 如何抓重点？

![所有知识点](F:\Note\IT\Platforms\极客时间\数据结构与算法之美王争\Pictures\入门篇\2\所有知识点.JPG)

抓重点学习，若不抓重点，都学，肯定吃力。

**常用的 10 个数据结构：**

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树

**常用的 10 个算法：**

递归、排序、二分查找、搜索、哈希算法、贪心、分治、回溯、动态规划、字符串匹配算法。

#### 关于刷题：

可以“适度”刷题，但一定不要浪费太多时间。学习的目的是掌握，然后应用。除非面 Google、Facebook 这样的公司，它们的算法题目非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。★★

---

学习需要沉淀，不要想试图一下子掌握所有，学习知识的过程是反复迭代、不断沉淀的过程。

### 3. 复杂度分析（上）：

复杂度分析是算法学习的精髓。

#### 为什么需要复杂度分析？而不是通过机器来计算？

复杂度分析是跨平台的，不依赖于环境。

#### 时间复杂度的规律：

代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比：

```
T(n) = O(f(n))
```

#### 关于 O(logn)：

所有的对数阶时间复杂度都可以记为 O(logn) ，为什么？

对数之间是可以相互转换的：

```
log₃n = log₃2 * log₂n
-> O(log₃n) = O(C * log₂n)
而 O(Cf(n)) = O(f(n))
-> O(log₂n) = O(log₃n)，表示为 O(logn)
```

#### 如何理解 O(nlogn) —— 归并、快速排序？

运用乘法法则：

若一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)

### 4. 复杂度分析（下）：

最好情况时间复杂度和最坏情况都是极端情况下的代码复杂度，发生的概率其实并不大。

#### 平均时间复杂度：

把每种情况发生的概率考虑进去。

#### 均摊时间复杂度：

> 均摊复杂度用到的情况比另外三种更特殊、更有限。

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到其他的操作上，结果就是 O(1) 。

> 一般情况下，在能运用均摊时间复杂度的场合，它就等于最好时间复杂度。★

### 5. 数组

#### 定义：

数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

#### 线性表：

数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

#### 非线性表：

与线性表对立，如：二叉树、堆、图等。之所以叫非线性表，是因为其中，数据之间不是简单的前后关系。

#### 能随机访问的秘密：

连续的内存空间和相同类型的数据。

#### 错误纠正：

我在面试时，常常会问数组和链表的区别，很多人回答，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)。

实际上，这种表述不准确，数组的查找时间复杂度并非 O(1)，即便是排好序的数组，你使用二分查找，也是 O(logn)。所以，正确的表述是：数组支持随机访问，根据下标随机访问的时间复杂度是 O(1) 。

#### 插入改进：

若元素的位置并不重要，那么将元素插入某位置，然后将该位置的元素直接放到数组末尾。

这个思想在快排中也会用到。

#### 删除改进：

若不追求数组中数据的连续性，可以先记录下已经删除的数据，每次的删除操作并非真正搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，在触发一次真正的删除，这样就大大减少了删除操作导致的数据搬移。

这就是 JVM 的核心思想。

#### 数据结构和算法的魅力：

很多时候我们并不是要去死记硬背某个数据结构或算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你留心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

#### 关于数组越界：

很多计算机病毒就是利用数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码一定要警惕数组越界。

在需要程序员来检查数组越界的语言，如：C，若数组越界，可能会产生死循环，而错误是非常隐蔽的，debug 难度极大：

```c
int i = 0;
int arr[3] = {0};
for (; i  <= 3; i++) {
    arr[i] = 0;
    printf("hello world\n");
}
return 0;
```

当 i = 3 时，数组越界，而访问的内存地址恰好是 i，那么此时 a[3] = 0 相当于 i = 0，所以代码无线循环。

#### 容器能否完全替代数组？

