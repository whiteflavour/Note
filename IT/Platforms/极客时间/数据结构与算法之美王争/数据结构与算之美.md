# 数据结构与算法之美 (2021.7.3 - 2021. )

## 入门篇：

### 1. 为什么学习数据结构与算法？

计算机，要学习基础，才能立于不败，因为技术更新很快，而基础的东西恰恰是那些不怎么变化的东西，也很难啃，算法即为其中之一。

掌握数据结构和算法，对阅读框架源码和理解其背后的设计思想非常有用。

### 2. 如何抓重点？

![所有知识点](F:\Note\IT\Platforms\极客时间\数据结构与算法之美王争\Pictures\入门篇\2 抓重点，系统学习数据结构与算法\所有知识点.JPG)

抓重点学习，若不抓重点，都学，肯定吃力。

**常用的 10 个数据结构：**

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树

**常用的 10 个算法：**

递归、排序、二分查找、搜索、哈希算法、贪心、分治、回溯、动态规划、字符串匹配算法。

#### 关于刷题：

可以“适度”刷题，但一定不要浪费太多时间。学习的目的是掌握，然后应用。除非面 Google、Facebook 这样的公司，它们的算法题目非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。★★

---

学习需要沉淀，不要想试图一下子掌握所有，学习知识的过程是反复迭代、不断沉淀的过程。

### 3. 复杂度分析（上）：

复杂度分析是算法学习的精髓。

#### 为什么需要复杂度分析？而不是通过机器来计算？

复杂度分析是跨平台的，不依赖于环境。

#### 时间复杂度的规律：

代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比：

```
T(n) = O(f(n))
```

#### 关于 O(logn)：

所有的对数阶时间复杂度都可以记为 O(logn) ，为什么？

对数之间是可以相互转换的：

```
log₃n = log₃2 * log₂n
-> O(log₃n) = O(C * log₂n)
而 O(Cf(n)) = O(f(n))
-> O(log₂n) = O(log₃n)，表示为 O(logn)
```

#### 如何理解 O(nlogn) —— 归并、快速排序？

运用乘法法则：

若一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn)

### 4. 复杂度分析（下）：

最好情况时间复杂度和最坏情况都是极端情况下的代码复杂度，发生的概率其实并不大。

#### 平均时间复杂度：

把每种情况发生的概率考虑进去。

#### 均摊时间复杂度：

> 均摊复杂度用到的情况比另外三种更特殊、更有限。

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到其他的操作上，结果就是 O(1) 。

> 一般情况下，在能运用均摊时间复杂度的场合，它就等于最好时间复杂度。★

## 基础篇：

### 5. 数组

#### 定义：

数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

#### 线性表：

数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

#### 非线性表：

与线性表对立，如：二叉树、堆、图等。之所以叫非线性表，是因为其中，数据之间不是简单的前后关系。

#### 能随机访问的秘密：

连续的内存空间和相同类型的数据。

#### 错误纠正：

我在面试时，常常会问数组和链表的区别，很多人回答，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)。

实际上，这种表述不准确，数组的查找时间复杂度并非 O(1)，即便是排好序的数组，你使用二分查找，也是 O(logn)。所以，正确的表述是：数组支持随机访问，根据下标随机访问的时间复杂度是 O(1) 。

#### 插入改进：

若元素的位置并不重要，那么将元素插入某位置，然后将该位置的元素直接放到数组末尾。

这个思想在快排中也会用到。

#### 删除改进：

若不追求数组中数据的连续性，可以先记录下已经删除的数据，每次的删除操作并非真正搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，在触发一次真正的删除，这样就大大减少了删除操作导致的数据搬移。

这就是 JVM 的核心思想。

#### 数据结构和算法的魅力：

很多时候我们并不是要去死记硬背某个数据结构或算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你留心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

#### 关于数组越界：

很多计算机病毒就是利用数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码一定要警惕数组越界。

在需要程序员来检查数组越界的语言，如：C，若数组越界，可能会产生死循环，而错误是非常隐蔽的，debug 难度极大：

```c
int i = 0;
int arr[3] = {0};
for (; i  <= 3; i++) {
    arr[i] = 0;
    printf("hello world\n");
}
return 0;
```

当 i = 3 时，数组越界，而访问的内存地址恰好是 i，那么此时 a[3] = 0 相当于 i = 0，所以代码无线循环。

#### 容器能否完全替代数组？

##### 关于 ArrayList：

因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

##### 何时使用数组？

1. 容器的自动装箱、拆箱需要消耗时间，如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList > array。

**总结**：对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

#### 为什么数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。

如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

```
a[k]_address = base_address + (k-1)*type_size
```

若从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是**多了一次减法指令**。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

### 6. 链表（上）

#### 缓存淘汰策略：

当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。

**常见的三种策略：**

1. 先进先出策略 FIFO（First In，First Out）
2. 最少使用策略 LFU（Least Frequently Used）
3. 最近最少使用策略 LRU（Least Recently Used）

这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？

#### 链表与数组的区别：

数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

而链表则通过“指针”将一组零散的内存块串联起来使用。

#### 双向链表：（如：Java 中的 LinkedHashMap）

在实际的软件开发中更加常用。

#### 关于链表删除节点：

1. 删除结点中“值等于某个给定值”的结点
2. 删除给定指针指向的结点。

#### 重要的设计思想：空间换时间

但是，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

#### 数组与链表性能比拼：

**访问速度：**

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

**扩容：**

如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

**当你的代码对内存要求苛刻时：**

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

#### 总结：

合适的才是最好的。

#### 如何基于链表实现 LRU 缓存淘汰算法？

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
   - 如果此时缓存未满，则将此结点直接插入到链表的头部
   - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

时间复杂度 O(n) 。

**优化**：

引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。（等讲到散列表时在细说）

#### 基于数组的 LRU ?

循环数组：使用两个指针，其中一个表示写入位置，另一个表示结束位置。当两个指针重合时，结束位置自动向前推进 1 步（可以自定义）。两个指针的移动需要取模来实现循环，从写入位置到结束位置即为待写入部分；而从结束位置到写入位置即为已经缓存的部分。

### 7. 链表（下）

#### 几个技巧：

##### 一、理解指针或引用的含义：

不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

##### 二、警惕指针丢失和内存泄漏

插入结点时，一定要注意操作的顺序，删除链表结点时，也一定要记得手动释放内存空间。（当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。）

##### 三、利用哨兵简化实现难度

对于单链表的**插入**操作，第一个结点和其他结点的插入逻辑是不一样的：

中间插入：

```c
new_node->next = p->next;
p->next = new_node;
```

空链表插入：

```c
if (head == null) {
  head = new_node;
}
```

**删除：**

```c
p->next = p->next->next;
```

删除尾结点：

```c
if (head->next == null) {
   head = null;
}
```

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。

**解决：——哨兵**

哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。

实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

**哨兵优化代码举例：**

**普通版本：**

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
int find(char* a, int n, char key) {
  // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
  if(a == null || n <= 0) {
    return -1;
  }
  
  int i = 0;
  // 这里有两个比较操作：i<n和a[i]==key.
  while (i < n) {
    if (a[i] == key) {
      return i;
    }
    ++i;
  }
  
  return -1;
}
```

**优化版本：**

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
// 我举2个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }
  
  // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;
  
  int i = 0;
  // while 循环比起代码一，少了i<n这个比较操作
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
    return -1;
  } else {
    // 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```

代码二运行更快，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句`i < n`，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。

> 当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。

##### 四、重点留意边界条件处理

我经常用来检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

当然，边界条件不止我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你自己去思考，不过套路都是一样的。

> 实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

##### 五、举例画图，辅助思考

你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化：

![画图法](F:\Note\IT\Platforms\极客时间\数据结构与算法之美王争\Pictures\基础篇\7 链表（下）\画图法.png)

##### 六、多写多练，没有捷径

#### 小结：

写链表代码是最考验逻辑思维能力的。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。

所以，这也是很多面试官喜欢让人手写链表代码的原因。

### 8. 栈：

#### 理解栈：

事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。

#### 支持动态扩容的顺序栈：（不常用）

#### 栈的应用：

1. 函数调用
2. 表达式求值，如计算：5 + 3 x 8 - 2
3. 括号匹配（LeetCode 上做过）

#### 如何实现浏览器的前进和后退功能？

我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。

#### 为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？

其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。

从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

### 9. 队列

